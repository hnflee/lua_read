# Lua5.1.4代码分析(二十四)-Lua GC原理

到了Lua GC部分，先简单介绍Lua GC的原理，后面再针对一些细节展开讨论。

Lua的GC算法使用的所谓“Mark And Sweep”算法。简单的理解，这个算法将GC分为两个阶段，一个是标记（mark）阶段，这一阶段将所有系统中引用的对象都逐一标记；而在清理（sweep）阶段，将把在mark阶段中没有被标记的数据删除。

在Lua中，使用几种颜色来区分不同的结点：
1.  white：白色表示没有进行过标记的节点
2.  gray：灰色表示已经进行过标记的节点，但是与它相关联的节点还没有进行过标记。
3.  black：本节点和与之关联的节点都已经被扫描标记过了。
通常会出现有关联数据的，包括有Table，upvalue等数据类型。

在这里需要注意的一个概念是，Lua实际上有两种白色，相互进行切换，比如本次扫描是第一种白色，下一次就是第二种白色了，之所以做这个区分，是为了区分不同的GC次数。比如某个节点，本次扫描发现既不能是灰色节点也不能是黑色节点，但是又不能不处理，那么就将其标记为另一种白色节点，到下一次GC时再处理了。

Lua的GC算法，大致可以用下面的伪代码表示，后面将针对这个算法的细节展开讨论：

```
当前所有对象都是White状态;
将root集合引用到的对象从White设置成Gray，并放到Gray集合中;
while(Gray集合不为空)
{
	从Gray集合中移除一个对象O，并将O设置成Black状态;
	for(O中每一个引用到的对象O1) {
				     if(O1在White状态) {
							将O1从White设置成Gray，并放到到Gray集合中；
								}
								}
}
for(任意一个对象O){
	if(O在White状态)
		销毁对象O;
		else
			将O设置成White状态;
}
```

